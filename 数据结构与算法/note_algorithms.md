写在前面

2021年1月中旬开始认真刷leetcode，首先瞄准了动态规划这个标签的题目，没有什么好说的，就是多练多总结，下面开始刷题写题解了......



# 1. 特点

某个问题要想能通过动态规划思想来解决，通常需要满足三个条件：

1. 最优子结构
2. 无后效性
3. 重复子问题



动态规划精髓：设计出状态量与每个状态步的决策策略，状态一般用子问题定义。



一开始看没理解上面👆写的东西没关系，在刷题中边刷边理解



# 2. 题解

## 2.1 [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 2.1.1 说明

一道经典动态规划题目，基本符合上方总结的特点。代码实现简洁，重点理解思路并关注动态规划特点。

### 2.1.2 题目描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

* 示例:

  * 输入: [-2,1,-3,4,-1,2,1,-5,4]
  * 输出: 6
  * 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

### 2.1.3 解题思路

* 如果用**暴力求解**，需穷举所有子序列，找出最大和，对于数组长度为n的问题，其时间复杂度为 **O(n<sup>2</sup>)**。

* **动态规划解法**：

  清楚到这是一道可以用动态规划来求解的题目后，我们要做的就是<u>确定决策策略</u>，也就是写出<u>状态转移方程</u>，那么当前更为重要的就是确定这个状态要取什么量了。

  1. 确定状态量

     状态量一般需要从题目描述中提取出来，所以一开始无法直接看出来的话就应该把题目多阅读理解几遍，这道题由于经典故比较容易确定出我们要设置的状态量为遍历数组时的当前最大子序和，这里设置为sum；

  2. 遍历数组，更新状态量

     这里就是要写出<u>状态量的更新策略</u>了

     用 a<sub>i</sub> 代表遍历到的某个数，f(i) 代表以第 i 个数结尾的连续子数组的最大和，写出状态转移方程如下：

     ==f(i) = max{f( i - 1 ) + a<sub>i</sub>,  a<sub>i</sub>}==

     

     Q：

     ​		怎么写出来的？（当然是要多练啦）

     A：

     ​		结合代码：

     ​		用 sum 模拟 f(i)，由于它确定的是当前以第 i 个数结尾的连续子数组的最大和，所以以第 i 个数结尾的连续子数组的最大和必然与第 ( i - 1 ) 个数结尾的连续子数组的最大和相关。

     ​		这里状态转移方程的含义可以这样理解：在遍历过程中，每次都判断前一个数的最大子序和 f( i - 1 ) 是否大于0，如果是则可以知道前一个数的最大子序和 f( i - 1 ) 对于当前最大子序和 f(i) 有增益效果，那么当前最大子序和 f(i) 就等于前一个数的最大子序和 f(i - 1) 加上当前遍历到的数值 a<sub>i</sub> ，如果不是说明前一个数的最大子序和 f(i - 1 ) 无增益效果，则当前最大子序和 f(i) 直接更新为当前遍历到的数值 a<sub>i</sub> 。

     

     另外，由于上方得到的每个当前最大子序和f(i)都是当前以第i个数结尾的连续子数组的最大和，所以还要设置一个值作为最终结果，即 ans，即完整数组的最大子序和。

  3. 结合分析过程考虑初始状态值

     这里将 ans 设为数组的第一个数，sum 设为0。

     

### 2.1.4 代码

```java
public int maxSubArray(int[] nums) {
	int ans = nums[0];		//	最终结果
	int sum = 0;			//	模拟f(i)
    for(num : nums){		//	遍历数组，实现状态转移方程
        if(sum > 0){
            sum = sum + num;
        }else{
            sum = num;
        }
        ans = Math.max(ans, sum);	//	仅用于保存最终结果，与方程无关
    }
	return ans;
}
```



## 2.2 [按摩师问题](https://leetcode-cn.com/problems/the-masseuse-lcci)/[打家劫舍](https://leetcode-cn.com/problems/house-robber/)

### 2.2.1 说明

一道经典动态规划题目，重点关注如何**消除后效性**从而达到符合用DP解决的目的并理解思路。



### 2.2.2 题目描述

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

* 示例1：
  * 输入： [1,2,3,1]
  * 输出： 4
  * 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
* 示例2：
  * 输入： [2,7,9,3,1]
  * 输出： 12
  * 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。



### 2.2.3 解题思路

我们可以将所有的预约按摩模拟为每天进行一次，昨天按摩的话，今天必须得休息一天，昨天没按摩的话，今天可以按摩也可以不按摩，这样更容易理解，也方便解题。



首先要知道什么是无后效性，无后效性一般满足两个点：

1. 后面的决策不会影响前面的决策；
2. 之前的状态怎么来的并不重要；

根据题目可以知道本题在解决过程中是会产生后效性这种问题的，即按摩师今天是否接受预约，与昨天有无接受预约是有相关联的，所以就要想办法消除这种关联性。



* 方法一：设计二维状态变量作为状态量

  1. 确定状态量

     要消除今天预约受昨天影响，可以设置二维状态数组 dp，**使当前状态值综合之前相关的状态值**（即具有前缀性质），这里设计状态数组的两个维度为：

     `dp[i][0]`：在区间 [0, i] 里，下标为 i 的这一天**不接受预约**的最大时长；

     `dp[i][1]`：在区间 [0, i] 里，下标为 i 的这一天**接受预约**的最大时长；

     其中第一维代表着天数，第二维保存了当前最优值的决策。

  2. 遍历数组，更新状态量

     注意：今天的状态只与昨天相关，而因为按摩师不能接受相邻的预约，所以需要进行分类讨论如下

     * 今天不接受预约的最大时长 = 昨天不接受预约的最大时长和昨天接受预约的最大时长中大的那个值；
   * 今天接受预约的最大时长 = 昨天不接受预约的最大时长和今天接受的预约时长之和；
     
  3. 结合分析过程考虑初始状态值

     第一天不接受预约的最大时长为0，接受预约的最大时长为这一天接受的预约时长，即<u>`dp[0][0] = 0`，`dp[0][1] = nums[0]`</u>

  递推方程可见方法二，道理都是一样的。

  

* 方法二：压缩状态量，将一维状态变量设计为状态量

  1. 确定状态量

     `dp[i]`：区间 [0, i] 里接受预约的最大时长

  2. 遍历数组，更新状态量

     一维状态变量是没办法像二维状态变量那样直观地限定下标为 i 这一天是否接受预约，但是要得到下标为 i 这一天的预约情况和预约的最大时长，同样需要分类讨论：

     * 今天接受预约，那么昨天一定休息，由于状态 dp[i - 1] 的定义涵盖了下标为 i - 1 这一天的预约情况，故下标为 i 这一天的状态只能从下标为 i - 2 这一天的状态转移而来，即 dp[i] = dp[i - 2] + nums[i]；
     * 今天不接受预约，那么昨天可以不休息也可以休息，下标为 i 这一天的状态可直接从昨天转移而来：即 dp[i] = dp[i - 1]

     根据分析，下标为 i 这一天的预约情况和在区间 [0, i] 里接受的预约的最大时长就很容易得出啦：==dp[i] = Max(dp[i - 1], dp[i - 2] + nums[i])==

  3. 结合分析过程考虑初始状态值

     第一天因为在分析过程中看作只有一天故必须接受预约，<u>`dp[0] = nums[0]`</u>，第二天由于不能连续接受预约的情况，故第二天接受预约的最大时长取第二天接受的预约时长与第一天接受的预约时长的最大值，<u>`dp[1] = Math.max(nums[0], nums[1])`</u>。

### 2.2.4 代码

* 方法1

```java
public int massage(int[] nums) {
	int len = nums.length;
    //	基本情况也要考虑到
    if(len == 0){
        return 0;
    }
    if(len == 1){
        return nums[0];
    }
    //	设计状态量
    int[][] dp = new int[len][2];
    //	base case
    dp[0][0] = 0;
    dp[0][1] = nums[0];
    
    for(int i = 1; i < len; i++){
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);
        dp[i][1] = dp[i-1][0] + nums[i];
    }
    
    //	根据分析可知最后一天的状态值是有考虑到之前所有天数的状况的，所以我们只需要得到按摩或者不按摩的最大值即可
    return Math.max(dp[len - 1][0], dp[len - 1][1]);
}
```

* 方法2

```java
public int massage(int[] nums) {
	int len = nums.length;
    //	基本情况也要考虑到
    if(len == 0){
        return 0;
    }
    if(len == 1){
        return nums[0];
    }
    
    //	设计状态量
    int[] dp = new int[len];
    //	base case 
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    
    for(int i = 2; i < len; i++){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    
    return dp[len - 1];
}
```

* 因为今天是否接受预约只与昨天接受预约的情况有关联，故可以进一步将空间复杂度压缩为 `O(1)`

```java
public int rob(int[] nums) {
    int pre2 = 0, pre1 = 0;
    for (int i = 0; i < nums.length; i++) {
        int cur = Math.max(pre2 + nums[i], pre1);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```



## 2.3 [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 2.3.1 说明

简单题



### 2.3.2 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

* 示例1：

  ```
  输入： 2
  输出： 2
  解释： 有两种方法可以爬到楼顶。
  1.  1 阶 + 1 阶
  2.  2 阶
  ```

* 示例2：

  ```
  输入： 3
  输出： 3
  解释： 有三种方法可以爬到楼顶。
  1.  1 阶 + 1 阶 + 1 阶
  2.  1 阶 + 2 阶
  3.  2 阶 + 1 阶
  ```



### 2.3.3 解题思路

* 设计状态量与状态转移方程

  这里可以用 `dp[i]` 表示爬到第 `i` 阶楼梯有 `dp[i]` 种方法（为了方便讨论，数组下标从 1 开始），而每个`dp[i]` 又可以通过以下方法得到

  ==dp[i] = dp[i - 1] + dp[i - 2]==

  **解释说明**：如要爬到第 `i` 个阶梯，可以在第 `i-1` 个阶梯爬 1 个台阶或在第 `i-2` 个阶梯爬 2 个台阶到达，故走到第 `i` 个阶梯的方法数为第 `i-1` 个阶梯的方法数与第 `i-2` 个阶梯的方法数之和。

* 明确初始状态步

  当 `i = 1` 时方法数为1，当 `i = 2` 时方法数为 2；

* 压缩状态量

  根据分析可以得知 `dp[i]` 只与 `dp[i-1]` 和 `dp[i-2]` 有关，所以可以只用两个变量来存储 `dp[i-1]` 和`dp[i-2]`，这样可以使空间复杂度由原来的 `O(N)` 变小为 `O(1)`。



### 2.3.4 代码

```java
public int climbStairs(int n) {
	if(n <= 2){
        return n;
    }
    int pre1 = 2, pre2 = 1;
    for(int i = 2; i < n; i++){
        int cur = pre1 + pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    
    return pre1;
}
```



## 2.4 [在环形街区打家劫舍](https://leetcode-cn.com/problems/house-robber-ii/description/)

### 2.4.1 说明

原打家劫舍的升级版



### 2.4.2 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

* 示例1：

  ```
  输入：nums = [2,3,2]
  输出：3
  解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
  ```

* 示例2：

  ```
  输入：nums = [1,2,3,1]
  输出：4
  解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
       偷窃到的最高金额 = 1 + 3 = 4 。
  ```



### 2.4.3 解题思路

环状的屋子意味着第一个屋子和最后一个屋子<b>只能选择一个偷窃</b>，因此可以把环状房屋问题转化为**两个单排排列房屋的子问题**：

* 在不偷窃第一个屋子的情况下，最大金额是 p1；
* 在不偷窃最后一个屋子的情况下，最大金额是 p2；

**综合偷窃的最大金额：max（p1, p2）**

接下来解决单列房屋的打家劫舍问题即可。



### 2.4.4 代码

```java
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }

        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
    }

    public int rob(int[] nums, int first, int last) {
        int pre2 = 0, pre1 = 0;
        for(int i = first; i <= last; i++){
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }

        return pre1;
    }
```

## 2.5 矩阵的最小路径和

### 2.5.1 说明

简单题

### 2.5.2 题目描述

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![minpath](E:\MyLearning\study_notes\算法题\dp\picture\minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= `grid[i][j]` <= 100

### 2.5.3 解题思路

* 设计状态量

  设 dp 为大小 m x n 矩阵，`dp[i][j]`的值代表走到 (i, j) 的最小路径和。

* 设计状态转移方程

  根据要求，只能向右或向下走，即当前单元格 (i, j) 只能从左方单元格 (i, j - 1) 或上方单元格 (i - 1, j) 走到，因此只需要考虑矩阵的上边界和左边界。

  走到当前单元格的最小路径和等于从左方单元格 (i, j - 1) 与从上方单元格 (i - 1, j) 走来的两个最小路径和中较小的值加上当前单元格的值 `grid[i][j]`，具体的四种情况如下：

  * 当左边和上边都是边界时（矩阵的起点）：即 i = 0，j = 0 时，`dp[i][j] = grid[i][j]`；
  * 当只有左边是边界时，只能从上边来：即 i != 0, j = 0 时，`dp[i][j] = dp[i][j] + grid[i - 1][j]`
  * 当只有上边是边界时，只能从左边来：即 i = 0, j != 0 时，`dp[i][j] = dp[i][j] + grid[i][j - 1]`
  * 左边和上边都不是边界时：即 i != 0，j != 0 时，`dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`；

* 为缩小空间复杂度，上述操作可以直接在 `grid[][]` 上进行求解。

### 2.5.4 代码

```java
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0){
                    continue;
                }else if(i == 0){
                    grid[i][j] = grid[i][j] + grid[i][j - 1];
                }else if(j == 0){
                    grid[i][j] = grid[i][j] + grid[i - 1][j];
                }else{
                    grid[i][j] = grid[i][j] + Math.min(grid[i][j - 1], grid[i - 1][j]);
                }
            }
        }

        return grid[m - 1][n - 1];
    }
```

## 2.6 矩阵的不同路径数

### 2.6.1 说明

中等题



### 2.6.2 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

### 2.6.3 解题思路

* 设计状态量

  设 `dp[i][j]` 为到达位置 `[i][j]` 的不同路径数。

* 设计状态转移方程

  根据要求，只能向右或向下走，即当前单元格 (i, j) 只能从左方单元格 (i, j - 1) 或上方单元格 (i - 1, j) 走到，因此只需要考虑矩阵的上边界和左边界。

  走到当前单元格的不同路径数等于从左方单元格 (i, j - 1) 与从上方单元格 (i - 1, j) 走来的不同路径数之和。

  所以可以得到状态转移方程：==`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`==

* 可将空间复杂度缩小为 O(n)；

### 2.6.4 代码

```java
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur, 1);
        //  由于状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]
        //  故只保留当前行和上一行的数据，这里用pre[j] = dp[i-1][j]
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                //  等价于cur[j] = pre[j] + cur[j - 1]
                cur[j] += cur[j - 1];
            }
        }
        return cur[n - 1];
    }
```

## 2.7 区域和检索

### 2.7.1 说明

简单题

### 2.7.2 题目描述

给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。

实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）

**示例：**

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

### 2.7.3 解题思路

求数组从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为元素 0 ~ i - 1的和，sum[j + 1] 为元素 0 ~ j 的和。

那么现在只需求出各个元素从第一个元素计起到对应元素的和即可。

### 2.7.4 代码

```java
class NumArray{
	private int[] sums;
    
    public NumArray(int[] nums){
        sums = new int[nums.length + 1];
        for(int i = 1; i <= nums.length; i++){
            sums[i] = sums[i - 1] + nums[i - 1];
        }
    }
    
    public int sumRange(int i, int j){
        return sums[j + 1] - sums[i];
    }
}
```

## 2.8 等差数列划分

### 2.8.1 说明

中等题

### 2.8.2 题目描述

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```

以下数列不是等差数列。

```
1, 1, 2, 5, 7
```

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

**示例:**

```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

### 2.8.3 解题思路

设 dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。

当 A[i - 1] - A[i] == A[i - 2] - A[i - 1] 时，[A[i - 2], A[i - 1], A[i]] 构成一个等差递增子区间。而且在以 A[i - 1] 为结尾的递增子区间后再加上一个 A[i]，一样可以构成新的递增子区间。

```
dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
```

根据以上分析，在 A[i - 1] - A[i] == A[i - 2] - A[i - 1] 时，dp[i] = dp[i - 1] + 1；

同时为得到最终结果，需要计算所有 A[i] 之和。

### 2.8.4 代码

```java
public int numberOfArithmeticSlices(int[] A) {
	if (A == null || A.length == 0) {
        return 0;
    }
    int n = A.length;
    int[] dp = new int[n];
    for (int i = 2; i < n; i++) {
        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    int total = 0;
    for (int cnt : dp) {
        total += cnt;
    }
    return total;
}
```

```java
public int numberOfArithmeticSlices(int[] A) {
	if(A.length < 2 || A == null){
        return 0;
    }
    int res = 0;
    int add = 0;
    for(int i = 2; i < A.length; i++){
    	if(A[i - 1] - A[i] == A[i - 2] - A[i - 1]){
        res += ++add;
    	}else{
        	add = 0;
    	}
   	}
    return res;
}
```

## 2.9 分割整数的最大乘积

### 2.9.1 说明

中等题，可用数学方法解决

### 2.9.2 题目描述

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

### 2.9.3 解题思路

[参考题解](https://leetcode-cn.com/problems/integer-break/solution/bao-li-sou-suo-ji-yi-hua-sou-suo-dong-tai-gui-hua-/)

#### 暴力搜索

对于给定的正整数 n ，穷举它的每一种情况并对所有情况求最大值。

![F(n)](E:\MyLearning\study_notes\算法题\dp\picture\F(n).jpg)

由图可得一个递归表达式：==F(n) = max{i * F(n - i)}, i = 1, 2, ..., n - 1==

上述表达式表明了 n - i 需要继续分解的情况，但如果 n - i 比 F(n - i) 要大，显然就不用再继续分解了。所以还要比较 i * (n - i) 与 i * F(n - i) 的大小关系，所以完整的递归表达式应为：==F(n) = max{i * F(n - i), i * (n - i)}, i = 1, 2, ..., n - 1==

具体实现为：

```java
// 暴力解法
public int integerBreak(int n) {
	if(n == 2){
        return 1;
    }
    int res = -1;
    for(int i = 1; i <= n - 1; i++){
        res = Math.max(res, Math.max(i * (n - i), i * integerBreak(n - i)));
    }
    return res;
}
```

#### 记忆化搜索

暴力搜索的时间复杂度为指数级别，这种耗时程度之大的原因是在递归过程中计算了很多重复值，例如，上图中 F(n - 2) 和 F(n - 3) 至少重复计算了两次，并且在后面会有更多次重复运算，而这部分重复运算完全是没有必要的，如果我们每次求完一个 F(i)，都将其保存起来，下次再求的时候直接读取保存的值就行了，这显然会节省大量时间。一般地，可以用一个备忘录数组存放每次的 F(i)，具体实现如下：

```java
// 记忆化搜索-自顶向下
int[] memory;
public int integerBreak(int n) {
    memory = new int[n + 1];
    return integerBreakHelper(n);
}
public int integerBreakHelper(int n) {
    if (n == 2) {
        return 1;
    }
    //	memory 的初始值为0，如果它不为0，说明已计算过，直接返回即可。
    if(memory[n] != 0){
        return memory[n];
    }
    int res = -1;
    for(int i = 1; i <= n - 1; i++){
        res = Math.max(res, Math.max(i * integerBreakHelper(n-i), i * (n - i)));
    }
    // 将每次计算的结果保存到备忘录数组
    memory[n] = res;
    return res;
}
```

#### 动态规划

记忆化搜索已完成了实际的功能，但它是递归实现，我们要将这种自顶向下的思路转换为自底向上，这也是记忆化搜索和 DP 的区别所在。

具体实现如下：

```java
// 动态规划
public int integerBreak(int n) {
	memory[2] = 1;
    for(int i = 3; i <= n; i++){
        for(int j = 1; j <= i - 1; j++){
            memory[i] = Math.max(memory[i], Math.max(j * memory[i - j], j * (i - j)))
        }
    }
    return memory[n];
}
```

### 2.9.4 代码

```java
public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i - 1; j++){
                dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));
            }
        }

        return dp[n];
}
```

## 2.10 按完全平方数分割整数

### 2.10.1 说明

中等题，可用数学方法解决

### 2.10.2 题目描述

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的最小数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

### 2.10.3 解题思路

* 设计状态量

  设 dp[i] 为组成当前数字的完全平方数的最少数量。

* 设计状态转移方程

  对数组进行遍历，每次要先把当前数字更新为最坏情况的结果，即 dp[i] = i ，然后计算可得到的完全平方数的最小数量，即 ==dp[i] = min(dp[i - j * j] + 1, dp[i])==

* 明确初始状态步

  - 首先初始化长度为 `n+1` 的数组 `dp`，每个位置都为 `0`
  - 如果 `n` 为 `0`，则结果为 `0`

### 2.10.4 代码

```java
public int numSquares(int n) {
 	int[] dp = new int[n + 1];
    for(int i = 1; i <= n; i++){
        dp[i] = i;
        for(int j = 1; i - j * j >= 0; j++){
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}
```

## 2.11 解码方法

### 2.11.1 说明

中等题

### 2.11.2 题目描述

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"111" 可以将 "1" 中的每个 "1" 映射为 "A" ，从而得到 "AAA" ，或者可以将 "11" 和 "1"（分别为 "K" 和 "A" ）映射为 "KA" 。注意，"06" 不能映射为 "F" ，因为 "6" 和 "06" 不同。

给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

**示例 1：**

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
**示例 2：**

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
**示例 3：**

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
**示例 4：**

输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串开头的 0 无法指向一个有效的字符。 

### 2.11.3 解题思路

* 设计状态量

  设 dp[i] 为当前位的数字对应的解码方法数量。

* 设计状态转移方程

  此题需分情况讨论：

### 2.11.4 代码

```java
public int numDecodings(String s) {
	if(s.length == 0){
        return 0;
    }	
    int pre = 1, cur = 1;
    for(int i = 1; i < s.length; i++){
        int tmp = cur;
        if(s.charAt(i) == '0'){
            if(s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2'){
                cur = pre;
            }else{
                return 0;
            }
        }else if(s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && s.charAt(i) >= '1' && s.charAt(i) <= '6')){
            cur = cur + pre;
        }
        pre = tmp;
    }
    return cur;
}
```



# 3. 背包问题

## 3.1 0-1背包问题

### 3.1.1 说明

0-1背包的特点就是：==每种物品仅有一件，只能选择放或不放，物品是无法分割的==。



### 3.1.2 题目描述

有一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在要用这个背包装物品，最多能装的价值是多少？

* 示例

  ```
  N = 3, W = 4
  wt = [2, 1, 3]
  val = [4, 2, 3]
  ```

  结果返回 6，选择前两件物品装进背包，总重量 3 小于 `W`，可以获得最大价值 6。



### 3.1.3 基本思路

**==用子问题定义状态==**：即 F[i, w] 表示前 i 件物品恰放入一个容量为 w 的背包可以获得的最大价值。则其状态转移方程为：

`F[i, w] = max{F[i - 1, w], F[i - 1, w - wt[i - 1]] + val[i - 1]}`

解释说明：

首先，由于 `i` 是从 1 开始的，而数组索引是从 0 开始的，所以第 `i` 个物品的重量应该是 `wt[i-1]`，这一点不要搞混。

由0-1背包问题的特点，当我们只考虑第` i `件物品放与不放的问题时，子问题 “将前` i `件物品放入容量为` w `的背包中” 就可以转换为一个只和前`i - 1`件物品相关的问题。

* 如果不放第` i `件物品，那么问题就转换为“前` i - 1 `件物品放入容量为 `w `的背包中”，价值为`F[i - 1, w]`；
* 如果放第` i `件物品，那么问题就转换为“前` i - 1 `件物品放入剩下的容量为` w - wt[i - 1] `的背包中”，此时能获得的最大价值就是` F[i - 1, w - wt[i - 1]] `再加上放入第` i `件物品获得的价值` val[i - 1]`；





### 3.1.4 代码

```java
public int KnapSack(int[] wt, int[] val){
    int i, j = 0;
    for(i = 0; i <= N; i++){	//	初始化第0列
        F[i][0] = 0;		
    }
    for(j = 1; i <= W; j++){	//	初始化第0行
        F[0][j] = 0;		
    }
    for(i = 1; i <= N; i++){	//	求F[i][j]
        for(j = 1; j <= W; j++){
            if(j < wt[i - 1]){
                F[i][j] = F[i - 1][j];
            } else{
                F[i][j] = Math.max(F[i - 1][j], F[i - 1][j - wt[i - 1]] + val[i - 1])
            }
        }
    }
    for(j = W, i = N; i > 0; i--){	//求装入背包的物品，x[i]=1表示有装该物品
        if(F[i][j] > F[i - 1][j]){
            x[i - 1] = 1;
            j = j - wt[i - 1];
        }else{
            x[i - 1] = 0;
        }
    }
    return F[N][W];			//	返回背包所得的最大价值
}
```



## 3.2 完全背包问题



[i]:
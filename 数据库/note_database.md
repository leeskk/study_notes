基础知识在下午整理后画出思维图

所以SQL中有如处理日期、处理数值等数据处理函数，开发时如需实现这些功能是要用SQL实现还是开发语言实现？就是说哪一种的效率和性能更好？

# 一、数据库基础

## 1. 最基础

### 1.1 术语

![数据库最基础的术语](E:\MyLearning\study_notes\数据库\pictures\数据库最基础的术语.png)

* 补充说明：
  * 数据库管理系统（DBMS）对应于数据库软件，DBMS可创建和操纵DB；
  * **数据类型**可限制数据种类，还可帮助正确排序数据，并在优化磁盘使用方面起重要作用；
  * 多列作为主键时主键值的规则必须应用到构成主键的所有列，且所有列值的组合必须是唯一的（但单个列的值可以不唯一）。

### 1.2 使用数据库

![使用数据库](E:\MyLearning\study_notes\数据库\pictures\使用数据库.png)

### 1.3 检索数据

![检索数据](E:\MyLearning\study_notes\数据库\pictures\检索数据.jpg)

* 补充说明

  * 一般除实际需求为表中的每个列，否则最好别使用 `*` 通配符，因为==检索不需要的列通常会降低检索和应用程序的性能==；

  * `DISTNICT`关键字不能部分使用：

    虽然能指示MySQL只返回某列中不同的值，但要注意的是`DISTNICT`关键字会应用于所有列而不仅是前置它的列。

    如：`SELECT DISTINCT id, price`，除非指定的两个列都不同，否则所有行都将被检索出来。

### 1.4 排序检索数据

![排序检索数据](E:\MyLearning\study_notes\数据库\pictures\排序检索数据.jpg)

* 补充说明
  * 关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义；
  * 按多个列排序时，排序完全按所规定的顺序进行，若已有的字段的所有值都是唯一的，那么不会按之后的字段排序；
  * **`ORDER BY`子句必须在`FROM`子句之后，`LIMIT`子句必须在`ORDER BY`子句之后**，否则会出错。

### 1.5 过滤数据

![过滤数据](E:\MyLearning\study_notes\数据库\pictures\过滤数据.jpg)

* 补充说明

  * <big>不</big>在客户机代码对返回数据进行循环以提取需要的行的原因：

    * 极大影响应用的性能
    * 使创建后的数据完全不具有可伸缩性

  * 同时使用`ORDER BY`和`WHERE`子句时，**`ORDER BY`子句必须位于`WHERE`子句之后**；

  * SQL（像多数语言一样）在处理`OR`操作符之前，优先处理`AND`操作符，即**`AND`在计算次序中的优先级更高**；

    控制优先级的一种方法：**添加圆括号**，因为圆括号具有较`AND`和`OR`操作符高的计算次序；

  * ==任何时候使用具有`AND`和`OR`操作符的`WHERE`子句，都应该使用圆括号明确地分组操作符！==

  * **`IN`操作符**可完成与`OR`操作符相同的功能，它具有的**优点**有：

    * 在使用长的合法选项清单时，`IN`操作符的语法更清楚且直观；
    * 在使用`IN`时，计算的次序更容易管理（因为使用的操作符更少）；
    * `IN`操作符一般比`OR`操作符清单执行更快；
    * `IN`的最大优点是可以包含其他`SELECT`语句，使得能够更动态地建立`WHERE`子句；

  * 在复杂的子句中，`NOT`操作符的作用很大，例如它在与`IN`操作符联合使用时，`NOT`使找出与条件列表不匹配的行非常简单；

    > <big>注意</big>，MySQL支持使用`NOT`对`IN`、`BETWEEN`和`EXISTS`子句取反，这与多数其他DBMS允许使用`NOT`对各种条件取反有很大区别。

  * **LIKE操作符+通配符过滤**方式的搜索模式中的字面值是**区分大小写**的；

    > 搜索模式（search pattern）：由字面值、通配符或二者组合构成的搜索条件。

  * 除了一个或多个字符外，**`%`还能匹配0个字符**，即`%`代表搜索模式中给定位置的0个、1个或多个字符；

  * ==尾空格可能会干扰通配符匹配==，解决方法：

    * 在搜索模式最后附加一个`%`；
    * 在`SELECT`后面使用函数限定具体字段去掉首尾空格（<u>更好的做法</u>）
      1. `RTrim(字段名)`函数去掉值右边所有的空格；
      2. `LTrim(字段名)`函数去掉值左边所有的空格；
      3. `Trim(字段名)`函数去掉值左右两边的空格；

  * 注意，**通配符无法匹配NULL值**，即使是`WHERE name LIKE '%' `也不能匹配用值NULL作为名字的行；

  * 与`%`能匹配0个字符不同，`_`总是匹配单个字符，不能多也不能少；

  * ==通配符使用技巧==：

    * 不过度使用通配符，有其他操作符能实现的应使用其他操作符；
    * 在确实需要使用通配符时，除非必要，否则不要把它们用在搜索模式的开始处。通配符置于搜索模式的开始处时搜索效率最低；
    * 仔细注意通配符的位置；

### 1.6 计算字段

![计算字段](E:\MyLearning\study_notes\数据库\pictures\计算字段.jpg)

* 补充说明
  * 一般来说，在数据库服务器上完成得到计算字段的相关操作比在客户机完成这些操作要快得多，因为DBMS是设计来快速有效地完成这种处理的；
  * 多数DBMS使用`+`或`||`来实现拼接，MySQL则使用`Concat()`函数来实现；
  * 别名有时也称为导出列（derived colunm）；

### 1.7 数据处理函数

不深究，需要使用时上网查阅。

* 如：

  * 文本处理函数：
    * 将文本转换为大写：`Upper()`
    * 返回串的长度：`Length()`
    * 将任何文本串转换为描述其语音能表示的字母数字模式的算法：`Soundex()`
    * .........
  * 日期和时间处理函数：
    * 返回当前日期：`CurDate()`
    * 计算两个日期之差：`DateDiff()`
    * .........
  * 数值处理函数：
    * 返回一个数的绝对值：`Abs()`
    * 返回圆周率：`Pi()`
    * ........

  ......

* 示例使用：

  搜索联系名的语音描述与给定联系名的发音相同的顾客

  ```sql
  SELECT name, contact
  FROM customers
  WHERE Soundex(contact) = Soundex('Y Lie')
  ```

* 注意
  
  * 函数没有SQL的可移植性强，但是有时使用它们能提高性能，使用的话要保证做好代码注释；

### 1.8 汇总数据

![汇总数据](E:\MyLearning\study_notes\数据库\pictures\汇总数据.jpg)

* 补充说明
  * 这些**聚集函数**是高效设计的，**用来汇总数据的话一般是比在客户机应用程序中计算要快得多**；
  
  * `AVG()`只用于单个列，且列名必须作为函数参数给出，若需取得多个列的平均值，必须使用多个`AVG()`函数；
  
  * `AVG()`函数忽略列值为NULL的行；
  
  * 如果指定列名，则指定列的值为空的行被`COUNT()`函数忽略，但如果`COUNT()`函数中用的是星号（*），则不会被忽略；
  
  * `MAX()` 函数和 `MIN()` 函数需要指定列名，都忽略列值为 NULL 值的行，一般用来返回任意列中的最大（最小）值，包括返回文本列中的最大（最小）值，在用于文本数据时，如果数据按照相应的列排序，则 `MAX()` 返回最后一行， `MIN()` 返回最前面的行；
  
  * `SUM()` 函数忽略列值为 NULL 的行；
  
  * 以上 5 个聚集函数都可以如下使用（MySQL 5 及后期版本）：
  
    * 对所有的行执行计算，指定 ALL 参数或不给参数（ALL 为默认）；
  
    * 只包含不同的值，指定 DISTINCT 参数；
  
      ```sql
      --例：平均值只考虑各个不同的价格的情况
      SELECT AVG(DISTINCT pro_price) AS avg_price
      FROM products
      WHERE vend_id = 1003;
      ```
  
      注意，DISTINCT 不能用于 COUNT(*) ，即 COUNT(DISTINCT) 会产生错误。

### 1.9 数据分组

* 补充说明

  * ==分组运行把数据分为多个逻辑组，以便能对每个组而不是整个结果集进行聚集计算；==
  * GROUP BY 子句可以包含任意数目的列，故能对分组进行嵌套，为数据分组提供更细致的控制；
  * 若使用了分组嵌套，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）；
  * **GROUP BY 子句**中列出的每个列必须都是检索列或有效的表达式（**注意：但不能是聚集函数**）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。**不能是别名**；
  * ==除聚集计算语句外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出；==
  * 如果分组列中具有 NULL 值，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组；
  * GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前；
  * ==WHERE 和 HAVING 的差别：==
    * WHERE 对行进行过滤，而 HAVING 对分组进行过滤；
    * WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤；
  * ==ORDER BY 和 GROUP BY 的差别：==
    * 

  